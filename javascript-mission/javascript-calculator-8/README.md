# 문자열 계산기

## 기능 명세서
1. 사용자에게 입력값을 받는다.
2. 사용자의 입력값을 검증한다.
3. 구분자를 모두 쉼표로 통일한다.(기본 구분자, 커스텀 구분자 모두)
4. 구분자를 제거한다.
4. 구분자를 제거했다면 남아있는 문자열 결과를 더한다.
5. 결과값을 검증한다.
6. 결과값을 출력한다.

## MVC 패턴 적용
App.js는 Controller.js에게 원하는 view와 model을 주입함으로써 추후 view가 변경된다 하여도 바뀐 view만 주입해주면 됩니다. 

Controller.js는 View.js와 Model.js을 연결하는 중재자 역할을 합니다. 이때 생성자로 전달받은 view, model을 그대로 연결시켜주기에 나중에 View나 Model이 변경되어도 Controller는 수정하지 않아도 됩니다.

View.js는 사용자의 입력과 출력을 담당합니다. input, print 메서드를 static으로 하지 않은 이유는 입출력 로직의 경우 외부 라이브러리와 의존하기 때문에 별도의 객체로서 관리되어야 하기 때문입니다.

Model.js는 이 문자열 계산기의 핵심 로직을 담당합니다. calculate 메서드로 Model.js가 하는 일을 추상화하였으며, calculate 메서드 내에서는 Parse클래스에서 토큰화 (문자열인 숫자만 남김)를 진행하고, 숫자로 변환하고, 이 결과를 합하여 출력하는 메서드를 이용하여 값을 반환합니다.

Parse.js는 문자열에서 구분자를 추출하고 해당 구분자로 문자열을 나눠서 문자열인 숫자값만 반환하는 파서 역할을 담당합니다. Parse 클래스도 Model 클래스와 마찬가지로 Parse 클래스 내의 메서드 하나하나를 직접 호출하는것이 아닌 tokenization 메서드만 호출하도록 캡슐화를 하였으며, tokenization 메서드에서는 구분자를 구하고, 해당 구분자가 포함된 문자열에서 구분자만 지워 문자열인 숫자만 남도록 합니다.

## 테스트
- Model.test.js: 전체적인 계산 로직과 예외 상황(음수 입력 등)을 검증합니다.
- Parse.test.js: 다양한 커스텀 구분자 상황에서 문자열이 정확하게 분리되는지 검증합니다.

## 고민했던 지점
- class 내부에서 static 키워드로 선언한 변수나 메서드들은 인스턴스화되지 않는다. 즉, 해당 클래스가 상태를 관리하지 않으면 static 키워드를 붙인다고 생각했다. 하지만 View 클래스에서는 상태가 없지만, 추후 상태가 추가될 수도 있고 외부 라이브러리와 의존관계를 맺는다면 테스트 시 인스턴스화를 해주는게 테스트 하기 좋다는 것을 알게 되었다. 따라서 View 클래스에서는 static 메서드를 만들지 않았다.

- Model 클래스 내부에 원래 구분자 추출, 구분자 제거 등의 메서드가 같이 있었지만 해당 메서드들은 Model에 있는게 맞는지 고민했다. 하지만 메인 로직은 "문자열을 더한다" 이고 문자열을 더하는 행위를 하기 위해 구분자를 추출하고, 구분자를 제거하는 등의 로직은 Parse 클래스로 분리해야겠다고 생각했다.

